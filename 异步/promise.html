<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>test promise</title>
</head>
<body>
    <script>
        window.onload=function (){

            // setTimeout会在本轮同步事件完成后下轮事件开始时执行 setTimeout(fn, 0)在下一轮“事件循环(event loop)”开始时执行，
            setTimeout(function (){
                    console.log('我是setTimeout');
            },0);

            // Promise总会在本轮所有同步事件执行完毕后执行,Promise参数为函数,函数的两个参数resolve()和reject()是Promise自带的函数
            const promise = new Promise(function (resolve,reject){
                // resolve会在本轮所有同步结束后执行
                resolve('test');
                console.log(123);
            });
            promise.then(function (value){
                console.log(value);
            }).catch(function (value){
                console.log(value);
            }).finally(() => {console.log('finally执行成功')});
            // finally是Promise依次执行后无论如何都会执行

            // 每一个Promise对象都resolve会resolve状态,有一个reject则reject,如果数组里不是Promise对象,默认用Promise.resolve()使其成为Promise对象 Promise.resolve()方法返回resolved状态的 Promise 对象。Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。
            // const p = Promise.all([p1, p2, p3]);


            // 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
            // const p = Promise.race([p1, p2, p3]);


            // 实际应用图片加载
            // const preloadImage = function (path) {
            //     return new Promise(function (resolve, reject) {
            //         const image = new Image();
            //         image.onload  = resolve;
            //         image.onerror = reject;
            //         image.src = path;
            //     });
            // };

        }
    </script>
</body>
</html>